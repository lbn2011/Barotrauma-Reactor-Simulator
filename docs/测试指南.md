# Barotrauma 反应堆模拟器测试指南

## 1. 测试环境设置

### 1.1 开发环境

- **操作系统**: Windows 10/11, macOS, Linux
- **Node.js**: v18.0.0 或更高版本
- **包管理器**: npm, yarn 或 pnpm
- **浏览器**: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+

### 1.2 测试工具

- **单元测试**: Vitest
- **端到端测试**: Playwright
- **代码质量**: ESLint, Prettier
- **类型检查**: TypeScript

### 1.3 环境配置

1. 克隆仓库

   ```bash
   git clone <repository-url>
   cd Barotrauma-Reactor-Simulator
   ```

2. 安装依赖

   ```bash
   npm install
   ```

3. 运行开发服务器
   ```bash
   npm run dev
   ```

## 2. 测试方法和策略

### 2.1 测试层次

1. **单元测试**: 测试单个函数和组件
2. **集成测试**: 测试模块间的交互
3. **端到端测试**: 测试完整的用户流程
4. **性能测试**: 测试系统响应时间和资源使用

### 2.2 测试覆盖范围

- **物理模型**: 所有核心物理计算函数
- **状态管理**: 所有状态更新和控制函数
- **用户界面**: 所有主要组件和交互
- **Web Workers**: 所有计算密集型任务

### 2.3 测试策略

1. **持续集成**: 每次提交时运行测试
2. **边界条件测试**: 测试极端情况和边界值
3. **回归测试**: 确保修复的问题不会再次出现
4. **负载测试**: 测试系统在高负载下的表现

## 3. 单元测试

### 3.1 物理模型测试

#### 3.1.1 中子物理模型测试

**测试文件**: `tests/unit/models/neutron.test.ts`

```typescript
import { calculateVoidCoefficient } from '../../src/models/neutron/voidCoefficient';
import { calculateXenonPoisoning } from '../../src/models/neutron/xenonPoisoning';
import { calculateControlRodPhysics } from '../../src/models/neutron/controlRodPhysics';

describe('中子物理模型测试', () => {
  test('空泡系数计算', () => {
    const result = calculateVoidCoefficient({
      α_void: 4.7e-5,
      Δα: 0.1,
      P_current: 1000,
      τ_delay: 1,
    });
    expect(result.ρ_void).toBeCloseTo(4.7e-6);
    expect(result.P_new).toBeCloseTo(1000.0047);
  });

  test('氙中毒计算', () => {
    const result = calculateXenonPoisoning({
      Xe: 1e15,
      I: 1e15,
      λ_Xe: 2.95e-5,
      λ_I: 2.87e-5,
      σ_Xe: 2.65e-18,
      φ: 1e13,
      γ_Xe: 0.0639,
      γ_I: 0.0639,
      Σ_f: 1e-22,
      dt: 1,
    });
    expect(result.Xe_new).toBeGreaterThan(0);
    expect(result.I_new).toBeGreaterThan(0);
  });

  test('控制棒物理计算', () => {
    const result = calculateControlRodPhysics({
      ρ_max: 0.01,
      z: 1,
      L: 5,
      ρ_graphite_effect: 0.005,
    });
    expect(result.ρ_rod).toBeCloseTo(0.005); // 石墨尖端效应
  });
});
```

#### 3.1.2 热工水力模型测试

**测试文件**: `tests/unit/models/thermal.test.ts`

```typescript
import { calculateEnergyBalance } from '../../src/models/thermal/energyBalance';
import { calculateMassBalance } from '../../src/models/thermal/massBalance';

describe('热工水力模型测试', () => {
  test('能量平衡计算', () => {
    const result = calculateEnergyBalance({
      P_nuclear: 1000,
      η_thermal: 0.98,
      h_steam: 3000,
      h_feedwater: 200,
      m_coolant: 100,
      c_p: 4.186,
      h_inlet: 3000,
      h_outlet: 2000,
      η_turbine: 0.85,
      η_generator: 0.98,
    });
    expect(result.Q_thermal).toBeCloseTo(980);
    expect(result.P_electrical).toBeGreaterThan(0);
  });

  test('质量平衡计算', () => {
    const result = calculateMassBalance({
      M_reactor: 1000,
      M_condenser: 500,
      M_deaerator: 300,
      m_feedwater: 10,
      m_steam: 8,
      m_condensate: 7,
      m_cooling: 1,
      m_steam_heating: 2,
      m_feedwater_out: 8,
    });
    expect(result.dM_reactor).toBeCloseTo(2);
    expect(result.dM_condenser).toBeCloseTo(0);
    expect(result.dM_deaerator).toBeCloseTo(1);
  });
});
```

### 3.2 状态管理测试

**测试文件**: `tests/unit/stores/reactorStore.test.ts`

```typescript
import {
  reactorStore,
  startSimulation,
  stopSimulation,
  resetSimulation,
} from '../../src/lib/stores/reactorStore';

describe('状态管理测试', () => {
  test('初始状态检查', () => {
    let state;
    const unsubscribe = reactorStore.subscribe((s) => {
      state = s;
    });

    expect(state.isRunning).toBe(false);
    expect(state.simulationTime).toBe(0);
    expect(state.controlRods.position).toBe(50);

    unsubscribe();
  });

  test('启动和停止模拟', () => {
    let state;
    const unsubscribe = reactorStore.subscribe((s) => {
      state = s;
    });

    startSimulation();
    expect(state.isRunning).toBe(true);

    stopSimulation();
    expect(state.isRunning).toBe(false);

    unsubscribe();
  });

  test('重置模拟', () => {
    let state;
    const unsubscribe = reactorStore.subscribe((s) => {
      state = s;
    });

    startSimulation();
    resetSimulation();

    expect(state.isRunning).toBe(false);
    expect(state.simulationTime).toBe(0);

    unsubscribe();
  });
});
```

### 3.3 工具函数测试

**测试文件**: `tests/unit/utils.test.ts`

```typescript
import { clamp, formatNumber, calculatePercentage } from '../../src/lib/utils';

describe('工具函数测试', () => {
  test('clamp 函数', () => {
    expect(clamp(5, 0, 10)).toBe(5);
    expect(clamp(-1, 0, 10)).toBe(0);
    expect(clamp(11, 0, 10)).toBe(10);
  });

  test('formatNumber 函数', () => {
    expect(formatNumber(1234.5678, 2)).toBe('1234.57');
    expect(formatNumber(1234, 0)).toBe('1234');
  });

  test('calculatePercentage 函数', () => {
    expect(calculatePercentage(50, 100)).toBe(50);
    expect(calculatePercentage(25, 200)).toBe(12.5);
  });
});
```

## 4. 集成测试

### 4.1 系统集成测试

**测试文件**: `tests/integration/system.test.ts`

```typescript
import { reactorStore, startSimulation, setTargetPower } from '../../src/lib/stores/reactorStore';
import { workerManager } from '../../src/workers/workerManager';

describe('系统集成测试', () => {
  test('模拟运行和功率控制', async () => {
    let state;
    const unsubscribe = reactorStore.subscribe((s) => {
      state = s;
    });

    // 初始化 Worker
    workerManager.initialize();

    // 启动模拟
    startSimulation();
    expect(state.isRunning).toBe(true);

    // 设置目标功率
    setTargetPower(75);
    expect(state.powerRegulation.targetPower).toBe(75);

    // 等待一段时间让系统响应
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // 停止模拟
    workerManager.terminate();

    unsubscribe();
  });
});
```

### 4.2 组件集成测试

**测试文件**: `tests/integration/components.test.ts`

```typescript
import { render, screen, fireEvent } from '@testing-library/svelte';
import Button from '../../src/lib/components/ui/button/button.svelte';
import Slider from '../../src/lib/components/ui/slider/slider.svelte';

describe('组件集成测试', () => {
  test('按钮组件', () => {
    render(Button, { props: { variant: 'default' } });
    const button = screen.getByRole('button');
    expect(button).toBeInTheDocument();
  });

  test('滑块组件', () => {
    render(Slider, { props: { value: [50], min: 0, max: 100 } });
    const slider = screen.getByRole('slider');
    expect(slider).toBeInTheDocument();
  });
});
```

## 5. 端到端测试

### 5.1 用户流程测试

**测试文件**: `tests/e2e/user-flow.test.ts`

```typescript
import { test, expect } from '@playwright/test';

test('完整的反应堆控制流程', async ({ page }) => {
  // 访问应用
  await page.goto('http://localhost:5173');

  // 检查页面加载
  await expect(page).toHaveTitle('Barotrauma 反应堆模拟器');

  // 启动模拟
  await page.click('text=启动模拟');
  await expect(page.locator('.status-indicator')).toHaveText('运行中');

  // 调整功率
  await page.fill('input[name="power"]', '75');
  await page.click('text=设置');

  // 检查功率值
  await expect(page.locator('.power-value')).toHaveText('75');

  // 停止模拟
  await page.click('text=停止模拟');
  await expect(page.locator('.status-indicator')).toHaveText('已停止');
});
```

### 5.2 故障模拟测试

**测试文件**: `tests/e2e/fault-simulation.test.ts`

```typescript
import { test, expect } from '@playwright/test';

test('故障模拟系统', async ({ page }) => {
  await page.goto('http://localhost:5173');

  // 启动模拟
  await page.click('text=启动模拟');

  // 触发故障
  await page.click('text=故障模拟');
  await page.click('text=触发冷却泵故障');

  // 检查警报
  await expect(page.locator('.alarm')).toBeVisible();
  await expect(page.locator('.alarm-message')).toHaveText('冷却泵故障');

  // 处理故障
  await page.click('text=应急冷却');
  await expect(page.locator('.alarm')).not.toBeVisible();
});
```

## 6. 性能测试

### 6.1 计算性能测试

**测试文件**: `tests/performance/calculation.test.ts`

```typescript
import { calculateReactorCore } from '../../src/models/systems/reactorCore';

describe('性能测试', () => {
  test('反应堆核心计算性能', () => {
    const start = performance.now();

    // 运行100次计算
    for (let i = 0; i < 100; i++) {
      calculateReactorCore({
        P_nuclear: 1000,
        M_reactor: 100000,
        M_condenser: 50000,
        M_deaerator: 30000,
        m_feedwater: 100,
        m_steam: 90,
        m_condensate: 80,
        m_cooling: 5,
        m_steam_heating: 10,
        m_feedwater_out: 90,
        η_thermal: 0.98,
        m_coolant: 1000,
        c_p: 4.186,
        h_inlet: 3000,
        h_outlet: 2000,
        η_turbine: 0.85,
        η_generator: 0.98,
        α_void: 4.7e-5,
        Δα: 0.01,
        τ_delay: 1,
        Xe: 1e15,
        I: 1e15,
        λ_Xe: 2.95e-5,
        λ_I: 2.87e-5,
        σ_Xe: 2.65e-18,
        φ: 1e13,
        γ_Xe: 0.0639,
        γ_I: 0.0639,
        Σ_f: 1e-22,
        ρ_max: 0.01,
        z: 2,
        L: 5,
        ρ_graphite_effect: 0.005,
        turbineStatus: true,
        steamPressure: 10,
        pressureSetpoint: 10,
        maxPressure: 15,
        steamFlowMax: 200,
        currentBypassPosition: 0,
        filterEfficiency: 0.9,
        purificationFlow: 10,
        maxPurificationFlow: 50,
        impurityConcentration: 0.1,
        maxImpurityConcentration: 1,
        purificationSystemStatus: true,
        waterLevel: 60,
        waterLevelSetpoint: 60,
        steamFlow: 90,
        feedwaterFlow: 100,
        operatingTime: 1000,
        componentStatus: {},
        environmentalFactors: {
          temperature: 25,
          vibration: 0.1,
          humidity: 50,
        },
        maintenanceLevel: 100,
        currentFaults: [],
        dt: 0.1,
      });
    }

    const end = performance.now();
    const duration = end - start;

    // 确保计算时间合理
    expect(duration).toBeLessThan(1000); // 1秒内完成100次计算
  });
});
```

### 6.2 渲染性能测试

**测试文件**: `tests/performance/rendering.test.ts`

```typescript
import { test, expect } from '@playwright/test';

test('渲染性能测试', async ({ page }) => {
  await page.goto('http://localhost:5173');

  // 启动模拟
  await page.click('text=启动模拟');

  // 测量渲染时间
  const metrics = await page.evaluate(() => {
    const start = performance.now();

    // 触发多次状态更新
    for (let i = 0; i < 50; i++) {
      window.dispatchEvent(new Event('force-render'));
    }

    const end = performance.now();
    return end - start;
  });

  expect(metrics).toBeLessThan(500); // 500ms内完成50次渲染
});
```

## 7. 测试流程

### 7.1 本地测试

1. 运行单元测试

   ```bash
   npm run test:unit
   ```

2. 运行集成测试

   ```bash
   npm run test:integration
   ```

3. 运行端到端测试

   ```bash
   npm run test:e2e
   ```

4. 运行性能测试

   ```bash
   npm run test:performance
   ```

5. 运行所有测试
   ```bash
   npm run test
   ```

### 7.2 持续集成测试

1. **GitHub Actions**: 配置文件位于 `.github/workflows/test.yml`

2. **测试触发条件**:
   - 推送至 main 分支
   - 提交 Pull Request
   - 手动触发

3. **测试报告**: 自动生成测试覆盖率报告

### 7.3 测试结果分析

1. **测试覆盖率**: 目标 > 80%
2. **测试失败**: 分析失败原因并修复
3. **性能指标**: 监控关键性能指标
4. **回归测试**: 确保修复不会引入新问题

## 8. 测试最佳实践

### 8.1 编写高质量测试

1. **明确的测试名称**: 描述测试的目的和预期结果
2. **独立的测试**: 每个测试应该独立运行
3. **边界条件**: 测试极端情况和边界值
4. **模拟依赖**: 使用模拟和存根减少外部依赖
5. **清晰的断言**: 断言应该明确表达预期结果

### 8.2 测试维护

1. **定期运行测试**: 确保测试与代码同步
2. **更新测试**: 当代码变更时更新测试
3. **删除过时测试**: 移除不再相关的测试
4. **测试文档**: 记录测试策略和覆盖范围

### 8.3 故障排查

1. **测试失败分析**:
   - 检查错误消息
   - 查看测试代码和被测试代码
   - 运行单个测试进行调试

2. **常见问题**:
   - **物理模型**: 参数范围错误
   - **状态管理**: 状态更新不同步
   - **Web Workers**: 序列化问题
   - **用户界面**: 事件处理错误

3. **解决方案**:
   - 检查参数验证
   - 确保状态更新的原子性
   - 正确处理 Worker 消息
   - 测试事件绑定和处理

## 9. 测试案例库

### 9.1 正常运行案例

1. **启动和停止模拟**
2. **功率调节**
3. **控制棒操作**
4. **故障处理**
5. **数据导出**

### 9.2 异常运行案例

1. **冷却系统故障**
2. **控制棒卡涩**
3. **蒸汽泄漏**
4. **电力中断**
5. **多重故障叠加**

### 9.3 边界条件案例

1. **最大功率运行**
2. **极低功率运行**
3. **快速功率变化**
4. **长时间运行**
5. **极端环境条件**

## 10. 总结

本测试指南提供了全面的测试方法和策略，确保 Barotrauma 反应堆模拟器的稳定性、可靠性和性能。通过系统化的测试流程，可以及早发现和修复问题，提高代码质量，为用户提供更好的模拟体验。

测试是一个持续的过程，随着系统的发展和功能的增加，测试套件也应该不断扩展和更新，以确保系统的长期稳定运行。

---

© 2026 lbn2011和ai共同开发

本测试指南如有更新，恕不另行通知。
